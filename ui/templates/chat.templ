package templates

import "github.com/google/uuid"

templ Chat(title string, video bool, interests []string) {
	@Base(title) {
		<div
			class="flex-1 flex flex-col min-h-0"
			hx-ext="ws"
			ws-connect="/chat-ws"
		>
			<div id="connection_status">
				<p>Connecting...</p>
			</div>
			<div id="interests_chat" class="flex gap-1 my-1">
				if len(interests) > 0 {
					<span class="text-chatopia-4">Interests: </span>
					for _, interest := range interests {
						@InterestPill(interest)
					}
				}
			</div>
			@ChatInner(uuid.Nil, uuid.Nil, true, video)
		</div>
	}
}

templ ChatInner(peerID uuid.UUID, strangerPeerID uuid.UUID, isCaller bool, video bool) {
	<div
		id="chat_inner"
		class="grow"
		hx-swap-oob="outerHTML"
	>
		<script>
			// This function sets up all event handlers for an active connection.
			// It's called by both the caller and the receiver once the connection is established.
			function setupChat(connection) {
				console.log('PeerJS DataConnection is open. Setting up chat handlers.');
				const chatBubbles = document.querySelector("#chat_bubbles");
				
				// Handle incoming data (messages from stranger)
				connection.on('data', data => {
					newChatBubble(data, false);
				});

				const chatForm = document.querySelector("#chat_form");
				const textarea = chatForm.querySelector("#chat_message");
				const sendChatButton = document.querySelector("#send_chat_button");

				// CRITICAL: To prevent multiple listeners on reconnect, clone the button to remove old listeners.
				const newButton = sendChatButton.cloneNode(true);
				sendChatButton.parentNode.replaceChild(newButton, sendChatButton);


				// Handle outgoing data (sending a message)
				newButton.addEventListener("click", (e) => {
					const message = textarea.value.trim();

					if (message) {
						newChatBubble(message, true);
						connection.send(message);
						textarea.value = "";
					}
				});

				textarea.addEventListener('keydown', e => {
					if(e.key == 'Enter' && !e.shiftKey){
						e.preventDefault();
						newButton.click();
					}
				});
				
			}

			function newChatBubble(message, isMe) {
				    const wrapper = document.createElement("div");
				    wrapper.classList.add("flex", "gap-1", "w-full", "text-sm", "sm:text-base", isMe ? "justify-end" : "justify-start");

				    const innerWrapper = document.createElement("div");
				    if (isMe) {
					innerWrapper.classList.add("flex", "gap-2", "p-2", "rounded-lg", "max-w-xs", "bg-blue-500", "text-white", "min-w-0");
				    } else {
					innerWrapper.classList.add("flex", "gap-2", "p-2", "rounded-lg", "max-w-xs", "bg-gray-200", "text-gray-800", "min-w-0");
				    }

				    const msg = document.createElement("p");
				    msg.classList.add("break-all", "whitespace-pre-line");
				    msg.innerText = message;

				    innerWrapper.append(msg);
				    wrapper.appendChild(innerWrapper);

				    const chatBubbles = document.querySelector("#chat_bubbles");
				    chatBubbles.appendChild(wrapper);
				    wrapper.scrollIntoView({ block: "end", behavior: "smooth" });
			}

			function wsConnectedToPeerMessage() {
				const chatSocket = window.socketWrapper;
				if (chatSocket) {
					chatSocket.send(JSON.stringify({ message_type: "peer_connected" }));
					console.log("Sent 'peer_connected' message via WebSocket.");
				} else {
					console.error("Socket wrapper not found on window object.");
				}
			}

			function wsEndConnectionMessage() {
				const chatSocket = window.socketWrapper;
				if (chatSocket) {
					chatSocket.send(JSON.stringify({ message_type: "end_connection" }));
					console.log("Sent 'end_connection' message via WebSocket.");
				} else {
					console.error("Socket wrapper not found on window object.");
				}
			}
		</script>
		<script>
			// TODO: maybe handle
			// Peer:           'close', 'disconnected' and 'error' events AND
			// DataConnection: 'close' and 'error' events gracefully
			if (window.peer) {
				console.log("Destroying previous Peer object.");
				window.peer.destroy();
			}

			// Use a single, persistent peer object. 'var' prevents re-declaration errors from HTMX swaps.
			if ({{ peerID }} !== {{ uuid.Nil }}) {
				console.log("Creating new Peer object with ID:", "{{ peerID }}");
				// TODO: remember to set the debug value to 0/1
				window.peer = new Peer({{ peerID }}, {
					//host: "192.168.115.47",
					//port: 9000,
					debug: 1,
					secure: false,
					config: {
						'iceServers': [
							{ urls: "stun:stun.l.google.com:19302" },
							{ urls: "turn:turn.bistri.com:80", username: "homeo", credential: "homeo" }
						]
					}
				});

				window.peer.on('error', err => {
					console.error('PeerJS error:', err.type, err);
				});

				window.peer.on('disconnected', () => {
					console.error('PeerJS disconnected');
					wsEndConnectionMessage()
				});

				window.peer.on('close', () => {
					console.error('PeerJS closed');
					wsEndConnectionMessage()
				});

				window.peer.on('open', id => {
					console.log('My peer ID is now registered with the server:', id);

					// We only try to connect if we have a strangerPeerID and a valid peer object.
					if ({{ strangerPeerID }} !== {{ uuid.Nil }}) {
						const isCaller = {{ isCaller }};
						var conn = null;
			
						// Setup text comm
						if (isCaller) {
							console.debug("Acting as CALLER. Connecting to:", "{{ strangerPeerID }}");

							conn = window.peer.connect({{ strangerPeerID }});

							conn.on('error', err => console.error('Connection error (caller):', err));
							conn.on('open', () => {
								wsConnectedToPeerMessage()
								setupChat(conn);
							});

						} else {
							console.log("Acting as RECEIVER. Waiting for connection...");

							window.peer.on('connection', (connection) => {
								console.log("Incoming connection received.");
								conn = connection;

								conn.on('error', err => console.error('Connection error (receiver):', err));
								 conn.on('open', () => {
									wsConnectedToPeerMessage()
									setupChat(conn);
								});
							});
						}

						// Setup video comm
						if ({{ video }}) {
							function addVideoStream (videoElement, stream){
								videoElement.srcObject = stream
								videoElement.style.transform = 'scaleX(-1)';
								videoElement.addEventListener('loadedmetadata', () => {
									videoElement.play();
								});
							}

							const localVideo= document.querySelector("#local_video");
							const remoteVideo= document.querySelector("#remote_video");

							if (isCaller){
								navigator.mediaDevices.getUserMedia({
									video: true,
									audio: true
								}).then(stream => {
									addVideoStream(localVideo, stream);

									console.log("ðŸ“¹ VIDEO CALL: initiated");
									const call = window.peer.call({{ strangerPeerID }}, stream);

									call.on('stream', partnerStream => {
										console.log("ðŸ“¹ VIDEO CALL: (caller) stream partnerStream accepted.");
										if (remoteVideo) {
											addVideoStream(remoteVideo, partnerStream);
										}
									})

									call.on('close', () => {
										if (remoteVideo) {
											remoteVideo.srcObject = null;
										}
									});

									call.on('error', err => {
										console.error("ðŸ“¹ VIDEO CALL: (caller) ", err);
									});
								}).catch(err => {
									console.error("Failed to get local stream:", err);
								});
							}else{
								let localStream = null;
								navigator.mediaDevices.getUserMedia({ video: true, audio: true })
									.then(stream => {
										localStream = stream;
										addVideoStream(localVideo, stream);
									}).catch(err => {
										console.error("Failed to get local stream for receiver:", err);
									});

								console.log("ðŸ“¹ VIDEO CALL: waiting for call");
								window.peer.on('call', call => {
									console.log("ðŸ“¹ VIDEO CALL: received");

									if (localStream) {
										call.answer(localStream);

										call.on('stream', callerStream => {
											if (remoteVideo) {
												addVideoStream(remoteVideo, callerStream);
											}
										});

										call.on('error', err => {
											console.log("ðŸ“¹ VIDEO CALL: (receiver) ", err);
										});
									} else {
										console.error("Call received, but local stream is not available to answer with.");
									}
								});
							} // Callee logic
						} // Setup video comm
					} // Stranger ID existence/validity check
				}) // Peer on 'open' event
			} // Peer ID existence/validity check
		</script>
		<div class="flex flex-col sm:flex-row py-4 gap-2">
			if video {
				<div class="">
					@VideoChat()
				</div>
			}
			<div class="flex-grow">
				@TextChat()
			</div>
		</div>
		@ActionButton_NewChat()
	</div>
}
